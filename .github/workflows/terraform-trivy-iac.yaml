name: Deploy Infrastructure

on:
  # Run when someone opens a PR that changes infrastructure code
  pull_request:
    paths: ['terraform-code/**']
  
  # Run when code is pushed to dev or main branches
  push:
    branches: [ dev, main ]
    paths: ['terraform-code/**']
  
  # Allow manual deployment with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: "Which environment do you want to deploy?"
        required: true
        type: choice
        options: [staging, production]

permissions:
  id-token: write    # Needed for Azure authentication
  contents: read     # Needed to read the repository

# Prevent multiple deployments running at the same time
concurrency:
  group: terraform-${{ github.workflow }}-${{ github.ref_name }}
  cancel-in-progress: true

jobs:
  deploy:
    name: Deploy Infrastructure
    runs-on: ubuntu-latest
    
    # Choose environment based on how the workflow was triggered
    environment: ${{ github.event_name == 'workflow_dispatch' && inputs.environment || (github.ref_name == 'main' && 'production' || 'staging') }}

    # Azure credentials for authentication
    env:
      ARM_CLIENT_ID:       ${{ secrets.AZURE_CLIENT_ID }}
      ARM_TENANT_ID:       ${{ secrets.AZURE_TENANT_ID }}
      ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      ARM_USE_OIDC:        true

    steps:
      # Get the latest code
      - name: Get code from repository
        uses: actions/checkout@v4

      # Figure out which environment we're deploying to
      - name: Determine target environment
        id: env
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "target=${{ github.event.inputs.environment }}" >> $GITHUB_OUTPUT
          elif [[ "${{ github.ref_name }}" == "main" ]]; then
            echo "target=production" >> $GITHUB_OUTPUT
          else
            echo "target=staging" >> $GITHUB_OUTPUT
          fi
          echo "Deploying to: ${{ steps.env.outputs.target }}"

      # Set up paths for this specific environment
      - name: Set up environment paths
        run: |
          echo "TF_DIR=terraform-code/environments/${{ steps.env.outputs.target }}" >> $GITHUB_ENV
          echo "TFVARS=${{ steps.env.outputs.target }}.tfvars" >> $GITHUB_ENV
          echo "Working with directory: terraform-code/environments/${{ steps.env.outputs.target }}"
          echo "Using variables file: ${{ steps.env.outputs.target }}.tfvars"

      # Install Terraform
      - name: Install Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.6

      # Login to Azure using OIDC (no passwords needed!)
      - name: Login to Azure
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      # Read which version of modules to use
      - name: Read module version
        run: |
          MODULE_VERSION=$(cat $TF_DIR/module-ref.txt | tr -d '[:space:]')
          echo "MODULE_REF=$MODULE_VERSION" >> $GITHUB_ENV
          echo "Using module version: $MODULE_VERSION"

      # Process templates if they exist
      - name: Process Terraform templates
        run: |
          if [ -d "terraform-code/stack" ] && [ -n "$(find terraform-code/stack -name '*.tmpl' -type f)" ]; then
            for template in terraform-code/stack/*.tmpl; do
              if [ -f "$template" ]; then
                output_file="${template%.tmpl}"
                envsubst < "$template" > "$output_file"
              fi
            done
          fi

      # Verify main.tf calls the stack module correctly
      - name: Verify main.tf configuration
        run: |
          if grep -q "module.*stack" "$TF_DIR/main.tf"; then
            echo "✅ main.tf calls stack module"
          else
            echo "❌ ERROR: main.tf doesn't call stack module"
            exit 1
          fi

      # Verify infrastructure modules exist
      - name: Verify infrastructure modules exist
        run: |
          git init /tmp/infra
          cd /tmp/infra
          git remote add origin https://github.com/rare-beauty/terraform-infrastructure.git
          git fetch --depth 1 origin "${MODULE_REF}" || {
            git fetch --depth 1 origin && git checkout "${MODULE_REF}" || exit 1
          }
          REQUIRED_MODULES="resourcegroup virtualnetwork subnet acr azurekeyvault aks rbac"
          for module in $REQUIRED_MODULES; do
            if [ ! -d "terraform/modules/$module" ]; then
              echo "❌ ERROR: Missing required module: $module"
              exit 1
            fi
          done

      # Verify required configuration files exist
      - name: Verify configuration files exist
        run: |
          if [ ! -f "$TF_DIR/provider.tf" ]; then exit 1; fi
          if [ ! -f "$TF_DIR/variable.tf" ]; then exit 1; fi
          if [ ! -f "$TF_DIR/${{ steps.env.outputs.target }}.tfvars" ]; then exit 1; fi
          if [ ! -f "$TF_DIR/main.tf" ]; then exit 1; fi

      # Clean up any old Terraform state
      - name: Clean up old Terraform cache
        run: |
          rm -rf "$TF_DIR/.terraform"
          rm -f  "$TF_DIR/.terraform.lock.hcl"

      # Format Terraform files
      - name: Format Terraform files
        run: terraform -chdir=$TF_DIR fmt -recursive

      # Verify formatting
      - name: Verify Terraform formatting
        run: terraform -chdir=$TF_DIR fmt -check -recursive

      # Initialize Terraform
      - name: Initialize Terraform
        run: terraform -chdir=$TF_DIR init -upgrade

      # Show version info
      - name: Show Terraform version info
        run: terraform -chdir=$TF_DIR version

      # Validate configuration
      - name: Validate Terraform configuration
        run: terraform -chdir=$TF_DIR validate

      # Create a plan
      - name: Create deployment plan
        run: terraform -chdir=$TF_DIR plan -input=false -var-file=$TFVARS -var="module_ref=$MODULE_REF" -out=tfplan

      # Convert plan to JSON
      - name: Convert plan to JSON
        run: terraform -chdir=$TF_DIR show -json tfplan > tfplan.json

      # --- Trivy/Checkov scans commented out ---
      # - name: Run security scan on code
      #   uses: bridgecrewio/checkov-action@v12
      #   with:
      #     directory: ${{ env.TF_DIR }}
      #     quiet: true
      #
      # - name: Run security scan on plan
      #   uses: bridgecrewio/checkov-action@v12
      #   with:
      #     file: ${{ env.TF_DIR }}/tfplan.json
      #     quiet: true

      # Manual approval for production
      - name: Request approval for production deployment
        if: steps.env.outputs.target == 'production'
        uses: trstringer/manual-approval@v1
        with:
          secret: ${{ secrets.GITHUB_TOKEN }}
          approvers: vinaypalvirk51, sukhdeep26
          minimum-approvals: 1

      # Deploy infrastructure
      - name: Deploy infrastructure
        if: steps.env.outputs.target != 'production' || github.event_name == 'workflow_dispatch'
        run: terraform -chdir=$TF_DIR apply -input=false -auto-approve tfplan
